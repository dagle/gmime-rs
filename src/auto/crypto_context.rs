// This file was generated by gir (https://github.com/gtk-rs/gir @ fe7a6ff+)
// from gir-files (https://github.com/gtk-rs/gir-files @ 33386b3)
// DO NOT EDIT

use ffi;
use glib::object::IsA;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::mem;
use std::ptr;

glib_wrapper! {
    pub struct CryptoContext(Object<ffi::GMimeCryptoContext, ffi::GMimeCryptoContextClass>);

    match fn {
        get_type => || ffi::g_mime_crypto_context_get_type(),
    }
}

impl CryptoContext {
    pub fn new(protocol: &str) -> CryptoContext {
        unsafe {
            from_glib_full(ffi::g_mime_crypto_context_new(protocol.to_glib_none().0))
        }
    }

    //pub fn register(protocol: &str, callback: /*Unknown conversion*//*Unimplemented*/CryptoContextNewFunc) {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_register() }
    //}
}

pub trait CryptoContextExt {
    //fn decrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, flags: /*Ignored*/DecryptFlags, session_key: P, istream: &Q, ostream: &R, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<DecryptResult>;

    //fn digest_id(&self, name: &str) -> /*Ignored*/DigestAlgo;

    //fn digest_name(&self, digest: /*Ignored*/DigestAlgo) -> Option<String>;

    //fn encrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, sign: bool, userid: P, flags: /*Ignored*/EncryptFlags, recipients: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 0, id: 28 }, istream: &Q, ostream: &R, error: /*Ignored*/Option<Error>) -> i32;

    //fn export_keys<P: IsA<Stream>>(&self, keys: &str, ostream: &P, error: /*Ignored*/Option<Error>) -> i32;

    fn get_encryption_protocol(&self) -> Option<String>;

    fn get_key_exchange_protocol(&self) -> Option<String>;

    fn get_signature_protocol(&self) -> Option<String>;

    //fn import_keys<P: IsA<Stream>>(&self, istream: &P, error: /*Ignored*/Option<Error>) -> i32;

    //fn set_request_password(&self, request_passwd: /*Unknown conversion*//*Unimplemented*/PasswordRequestFunc);

    //fn sign<P: IsA<Stream>, Q: IsA<Stream>>(&self, detach: bool, userid: &str, istream: &P, ostream: &Q, error: /*Ignored*/Option<Error>) -> i32;

    //fn verify<'a, 'b, P: IsA<Stream>, Q: IsA<Stream> + 'a, R: Into<Option<&'a Q>>, S: IsA<Stream> + 'b, T: Into<Option<&'b S>>>(&self, flags: /*Ignored*/VerifyFlags, istream: &P, sigstream: R, ostream: T, error: /*Ignored*/Option<Error>) -> Option<SignatureList>;
}

impl<O: IsA<CryptoContext>> CryptoContextExt for O {
    //fn decrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, flags: /*Ignored*/DecryptFlags, session_key: P, istream: &Q, ostream: &R, error: /*Ignored*/Option<Error>) -> /*Ignored*/Option<DecryptResult> {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_decrypt() }
    //}

    //fn digest_id(&self, name: &str) -> /*Ignored*/DigestAlgo {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_digest_id() }
    //}

    //fn digest_name(&self, digest: /*Ignored*/DigestAlgo) -> Option<String> {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_digest_name() }
    //}

    //fn encrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, sign: bool, userid: P, flags: /*Ignored*/EncryptFlags, recipients: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 0, id: 28 }, istream: &Q, ostream: &R, error: /*Ignored*/Option<Error>) -> i32 {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_encrypt() }
    //}

    //fn export_keys<P: IsA<Stream>>(&self, keys: &str, ostream: &P, error: /*Ignored*/Option<Error>) -> i32 {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_export_keys() }
    //}

    fn get_encryption_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_encryption_protocol(self.to_glib_none().0))
        }
    }

    fn get_key_exchange_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_key_exchange_protocol(self.to_glib_none().0))
        }
    }

    fn get_signature_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_signature_protocol(self.to_glib_none().0))
        }
    }

    //fn import_keys<P: IsA<Stream>>(&self, istream: &P, error: /*Ignored*/Option<Error>) -> i32 {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_import_keys() }
    //}

    //fn set_request_password(&self, request_passwd: /*Unknown conversion*//*Unimplemented*/PasswordRequestFunc) {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_set_request_password() }
    //}

    //fn sign<P: IsA<Stream>, Q: IsA<Stream>>(&self, detach: bool, userid: &str, istream: &P, ostream: &Q, error: /*Ignored*/Option<Error>) -> i32 {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_sign() }
    //}

    //fn verify<'a, 'b, P: IsA<Stream>, Q: IsA<Stream> + 'a, R: Into<Option<&'a Q>>, S: IsA<Stream> + 'b, T: Into<Option<&'b S>>>(&self, flags: /*Ignored*/VerifyFlags, istream: &P, sigstream: R, ostream: T, error: /*Ignored*/Option<Error>) -> Option<SignatureList> {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_verify() }
    //}
}
