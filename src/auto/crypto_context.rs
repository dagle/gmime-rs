// This file was generated by gir (https://github.com/gtk-rs/gir @ fe7a6ff+)
// from gir-files (https://github.com/gtk-rs/gir-files @ 33386b3)
// DO NOT EDIT

use DigestAlgo;
use Error;
use SignatureList;
use Stream;
use VerifyFlags;
use ffi;
use glib::object::IsA;
use glib::translate::*;
use glib_ffi;
use gobject_ffi;
use std::mem;
use std::ptr;

glib_wrapper! {
    pub struct CryptoContext(Object<ffi::GMimeCryptoContext, ffi::GMimeCryptoContextClass>);

    match fn {
        get_type => || ffi::g_mime_crypto_context_get_type(),
    }
}

impl CryptoContext {
    pub fn new(protocol: &str) -> CryptoContext {
        unsafe {
            from_glib_full(ffi::g_mime_crypto_context_new(protocol.to_glib_none().0))
        }
    }

    //pub fn register(protocol: &str, callback: /*Unknown conversion*//*Unimplemented*/CryptoContextNewFunc) {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_register() }
    //}
}

pub trait CryptoContextExt {
    //fn decrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, flags: DecryptFlags, session_key: P, istream: &Q, ostream: &R) -> Result</*Ignored*/DecryptResult, Error>;

    fn digest_id(&self, name: &str) -> DigestAlgo;

    fn digest_name(&self, digest: DigestAlgo) -> Option<String>;

    //fn encrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, sign: bool, userid: P, flags: EncryptFlags, recipients: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 0, id: 28 }, istream: &Q, ostream: &R) -> Result<i32, Error>;

    fn export_keys<P: IsA<Stream>>(&self, keys: &str, ostream: &P) -> Result<i32, Error>;

    fn get_encryption_protocol(&self) -> Option<String>;

    fn get_key_exchange_protocol(&self) -> Option<String>;

    fn get_signature_protocol(&self) -> Option<String>;

    fn import_keys<P: IsA<Stream>>(&self, istream: &P) -> Result<i32, Error>;

    //fn set_request_password(&self, request_passwd: /*Unknown conversion*//*Unimplemented*/PasswordRequestFunc);

    fn sign<P: IsA<Stream>, Q: IsA<Stream>>(&self, detach: bool, userid: &str, istream: &P, ostream: &Q) -> Result<i32, Error>;

    fn verify<'a, 'b, P: IsA<Stream>, Q: IsA<Stream> + 'a, R: Into<Option<&'a Q>>, S: IsA<Stream> + 'b, T: Into<Option<&'b S>>>(&self, flags: VerifyFlags, istream: &P, sigstream: R, ostream: T) -> Result<Option<SignatureList>, Error>;
}

impl<O: IsA<CryptoContext>> CryptoContextExt for O {
    //fn decrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, flags: DecryptFlags, session_key: P, istream: &Q, ostream: &R) -> Result</*Ignored*/DecryptResult, Error> {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_decrypt() }
    //}

    fn digest_id(&self, name: &str) -> DigestAlgo {
        unsafe {
            from_glib(ffi::g_mime_crypto_context_digest_id(self.to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn digest_name(&self, digest: DigestAlgo) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_digest_name(self.to_glib_none().0, digest.to_glib()))
        }
    }

    //fn encrypt<'a, P: Into<Option<&'a str>>, Q: IsA<Stream>, R: IsA<Stream>>(&self, sign: bool, userid: P, flags: EncryptFlags, recipients: /*Unknown conversion*//*Unimplemented*/PtrArray TypeId { ns_id: 0, id: 28 }, istream: &Q, ostream: &R) -> Result<i32, Error> {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_encrypt() }
    //}

    fn export_keys<P: IsA<Stream>>(&self, keys: &str, ostream: &P) -> Result<i32, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_mime_crypto_context_export_keys(self.to_glib_none().0, keys.to_glib_none().0, ostream.to_glib_none().0, &mut error);
            if error.is_null() { Ok(ret) } else { Err(from_glib_full(error)) }
        }
    }

    fn get_encryption_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_encryption_protocol(self.to_glib_none().0))
        }
    }

    fn get_key_exchange_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_key_exchange_protocol(self.to_glib_none().0))
        }
    }

    fn get_signature_protocol(&self) -> Option<String> {
        unsafe {
            from_glib_none(ffi::g_mime_crypto_context_get_signature_protocol(self.to_glib_none().0))
        }
    }

    fn import_keys<P: IsA<Stream>>(&self, istream: &P) -> Result<i32, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_mime_crypto_context_import_keys(self.to_glib_none().0, istream.to_glib_none().0, &mut error);
            if error.is_null() { Ok(ret) } else { Err(from_glib_full(error)) }
        }
    }

    //fn set_request_password(&self, request_passwd: /*Unknown conversion*//*Unimplemented*/PasswordRequestFunc) {
    //    unsafe { TODO: call ffi::g_mime_crypto_context_set_request_password() }
    //}

    fn sign<P: IsA<Stream>, Q: IsA<Stream>>(&self, detach: bool, userid: &str, istream: &P, ostream: &Q) -> Result<i32, Error> {
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_mime_crypto_context_sign(self.to_glib_none().0, detach.to_glib(), userid.to_glib_none().0, istream.to_glib_none().0, ostream.to_glib_none().0, &mut error);
            if error.is_null() { Ok(ret) } else { Err(from_glib_full(error)) }
        }
    }

    fn verify<'a, 'b, P: IsA<Stream>, Q: IsA<Stream> + 'a, R: Into<Option<&'a Q>>, S: IsA<Stream> + 'b, T: Into<Option<&'b S>>>(&self, flags: VerifyFlags, istream: &P, sigstream: R, ostream: T) -> Result<Option<SignatureList>, Error> {
        let sigstream = sigstream.into();
        let sigstream = sigstream.to_glib_none();
        let ostream = ostream.into();
        let ostream = ostream.to_glib_none();
        unsafe {
            let mut error = ptr::null_mut();
            let ret = ffi::g_mime_crypto_context_verify(self.to_glib_none().0, flags.to_glib(), istream.to_glib_none().0, sigstream.0, ostream.0, &mut error);
            if error.is_null() { Ok(from_glib_full(ret)) } else { Err(from_glib_full(error)) }
        }
    }
}
