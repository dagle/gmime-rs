// This file was generated by gir (https://github.com/gtk-rs/gir @ 2f0a317)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8)
// DO NOT EDIT

use ffi;
use glib::translate::*;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum AddressType {
    Sender,
    From,
    ReplyTo,
    To,
    Cc,
    Bcc,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AddressType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AddressType::{}", match *self {
            AddressType::Sender => "Sender",
            AddressType::From => "From",
            AddressType::ReplyTo => "ReplyTo",
            AddressType::To => "To",
            AddressType::Cc => "Cc",
            AddressType::Bcc => "Bcc",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for AddressType {
    type GlibType = ffi::GMimeAddressType;

    fn to_glib(&self) -> ffi::GMimeAddressType {
        match *self {
            AddressType::Sender => ffi::GMIME_ADDRESS_TYPE_SENDER,
            AddressType::From => ffi::GMIME_ADDRESS_TYPE_FROM,
            AddressType::ReplyTo => ffi::GMIME_ADDRESS_TYPE_REPLY_TO,
            AddressType::To => ffi::GMIME_ADDRESS_TYPE_TO,
            AddressType::Cc => ffi::GMIME_ADDRESS_TYPE_CC,
            AddressType::Bcc => ffi::GMIME_ADDRESS_TYPE_BCC,
            AddressType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeAddressType> for AddressType {
    fn from_glib(value: ffi::GMimeAddressType) -> Self {
        match value {
            0 => AddressType::Sender,
            1 => AddressType::From,
            2 => AddressType::ReplyTo,
            3 => AddressType::To,
            4 => AddressType::Cc,
            5 => AddressType::Bcc,
            value => AddressType::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum AutocryptPreferEncrypt {
    None,
    Mutual,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for AutocryptPreferEncrypt {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "AutocryptPreferEncrypt::{}", match *self {
            AutocryptPreferEncrypt::None => "None",
            AutocryptPreferEncrypt::Mutual => "Mutual",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for AutocryptPreferEncrypt {
    type GlibType = ffi::GMimeAutocryptPreferEncrypt;

    fn to_glib(&self) -> ffi::GMimeAutocryptPreferEncrypt {
        match *self {
            AutocryptPreferEncrypt::None => ffi::GMIME_AUTOCRYPT_PREFER_ENCRYPT_NONE,
            AutocryptPreferEncrypt::Mutual => ffi::GMIME_AUTOCRYPT_PREFER_ENCRYPT_MUTUAL,
            AutocryptPreferEncrypt::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeAutocryptPreferEncrypt> for AutocryptPreferEncrypt {
    fn from_glib(value: ffi::GMimeAutocryptPreferEncrypt) -> Self {
        match value {
            0 => AutocryptPreferEncrypt::None,
            1 => AutocryptPreferEncrypt::Mutual,
            value => AutocryptPreferEncrypt::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum EncryptFlags {
    None,
    AlwaysTrust,
    NoCompress,
    Symmetric,
    ThrowKeyids,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for EncryptFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "EncryptFlags::{}", match *self {
            EncryptFlags::None => "None",
            EncryptFlags::AlwaysTrust => "AlwaysTrust",
            EncryptFlags::NoCompress => "NoCompress",
            EncryptFlags::Symmetric => "Symmetric",
            EncryptFlags::ThrowKeyids => "ThrowKeyids",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for EncryptFlags {
    type GlibType = ffi::GMimeEncryptFlags;

    fn to_glib(&self) -> ffi::GMimeEncryptFlags {
        match *self {
            EncryptFlags::None => ffi::GMIME_ENCRYPT_NONE,
            EncryptFlags::AlwaysTrust => ffi::GMIME_ENCRYPT_ALWAYS_TRUST,
            EncryptFlags::NoCompress => ffi::GMIME_ENCRYPT_NO_COMPRESS,
            EncryptFlags::Symmetric => ffi::GMIME_ENCRYPT_SYMMETRIC,
            EncryptFlags::ThrowKeyids => ffi::GMIME_ENCRYPT_THROW_KEYIDS,
            EncryptFlags::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeEncryptFlags> for EncryptFlags {
    fn from_glib(value: ffi::GMimeEncryptFlags) -> Self {
        match value {
            0 => EncryptFlags::None,
            1 => EncryptFlags::AlwaysTrust,
            16 => EncryptFlags::NoCompress,
            32 => EncryptFlags::Symmetric,
            64 => EncryptFlags::ThrowKeyids,
            value => EncryptFlags::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum FilterFromMode {
    Default,
    Armor,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FilterFromMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FilterFromMode::{}", match *self {
            FilterFromMode::Default => "Default",
            FilterFromMode::Armor => "Armor",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FilterFromMode {
    type GlibType = ffi::GMimeFilterFromMode;

    fn to_glib(&self) -> ffi::GMimeFilterFromMode {
        match *self {
            FilterFromMode::Default => ffi::GMIME_FILTER_FROM_MODE_DEFAULT,
            FilterFromMode::Armor => ffi::GMIME_FILTER_FROM_MODE_ARMOR,
            FilterFromMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeFilterFromMode> for FilterFromMode {
    fn from_glib(value: ffi::GMimeFilterFromMode) -> Self {
        match value {
            0 => FilterFromMode::Default,
            1 => FilterFromMode::Armor,
            value => FilterFromMode::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum FilterGZipMode {
    Zip,
    Unzip,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for FilterGZipMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "FilterGZipMode::{}", match *self {
            FilterGZipMode::Zip => "Zip",
            FilterGZipMode::Unzip => "Unzip",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for FilterGZipMode {
    type GlibType = ffi::GMimeFilterGZipMode;

    fn to_glib(&self) -> ffi::GMimeFilterGZipMode {
        match *self {
            FilterGZipMode::Zip => ffi::GMIME_FILTER_GZIP_MODE_ZIP,
            FilterGZipMode::Unzip => ffi::GMIME_FILTER_GZIP_MODE_UNZIP,
            FilterGZipMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeFilterGZipMode> for FilterGZipMode {
    fn from_glib(value: ffi::GMimeFilterGZipMode) -> Self {
        match value {
            0 => FilterGZipMode::Zip,
            1 => FilterGZipMode::Unzip,
            value => FilterGZipMode::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Format {
    Message,
    Mbox,
    Mmdf,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Format {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Format::{}", match *self {
            Format::Message => "Message",
            Format::Mbox => "Mbox",
            Format::Mmdf => "Mmdf",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Format {
    type GlibType = ffi::GMimeFormat;

    fn to_glib(&self) -> ffi::GMimeFormat {
        match *self {
            Format::Message => ffi::GMIME_FORMAT_MESSAGE,
            Format::Mbox => ffi::GMIME_FORMAT_MBOX,
            Format::Mmdf => ffi::GMIME_FORMAT_MMDF,
            Format::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeFormat> for Format {
    fn from_glib(value: ffi::GMimeFormat) -> Self {
        match value {
            0 => Format::Message,
            1 => Format::Mbox,
            2 => Format::Mmdf,
            value => Format::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum NewLineFormat {
    Unix,
    Dos,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for NewLineFormat {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "NewLineFormat::{}", match *self {
            NewLineFormat::Unix => "Unix",
            NewLineFormat::Dos => "Dos",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for NewLineFormat {
    type GlibType = ffi::GMimeNewLineFormat;

    fn to_glib(&self) -> ffi::GMimeNewLineFormat {
        match *self {
            NewLineFormat::Unix => ffi::GMIME_NEWLINE_FORMAT_UNIX,
            NewLineFormat::Dos => ffi::GMIME_NEWLINE_FORMAT_DOS,
            NewLineFormat::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeNewLineFormat> for NewLineFormat {
    fn from_glib(value: ffi::GMimeNewLineFormat) -> Self {
        match value {
            0 => NewLineFormat::Unix,
            1 => NewLineFormat::Dos,
            value => NewLineFormat::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum OpenPGPData {
    None,
    Encrypted,
    Signed,
    PublicKey,
    PrivateKey,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for OpenPGPData {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "OpenPGPData::{}", match *self {
            OpenPGPData::None => "None",
            OpenPGPData::Encrypted => "Encrypted",
            OpenPGPData::Signed => "Signed",
            OpenPGPData::PublicKey => "PublicKey",
            OpenPGPData::PrivateKey => "PrivateKey",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for OpenPGPData {
    type GlibType = ffi::GMimeOpenPGPData;

    fn to_glib(&self) -> ffi::GMimeOpenPGPData {
        match *self {
            OpenPGPData::None => ffi::GMIME_OPENPGP_DATA_NONE,
            OpenPGPData::Encrypted => ffi::GMIME_OPENPGP_DATA_ENCRYPTED,
            OpenPGPData::Signed => ffi::GMIME_OPENPGP_DATA_SIGNED,
            OpenPGPData::PublicKey => ffi::GMIME_OPENPGP_DATA_PUBLIC_KEY,
            OpenPGPData::PrivateKey => ffi::GMIME_OPENPGP_DATA_PRIVATE_KEY,
            OpenPGPData::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeOpenPGPData> for OpenPGPData {
    fn from_glib(value: ffi::GMimeOpenPGPData) -> Self {
        match value {
            0 => OpenPGPData::None,
            1 => OpenPGPData::Encrypted,
            2 => OpenPGPData::Signed,
            3 => OpenPGPData::PublicKey,
            4 => OpenPGPData::PrivateKey,
            value => OpenPGPData::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum ParamEncodingMethod {
    Default,
    Rfc2231,
    Rfc2047,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for ParamEncodingMethod {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "ParamEncodingMethod::{}", match *self {
            ParamEncodingMethod::Default => "Default",
            ParamEncodingMethod::Rfc2231 => "Rfc2231",
            ParamEncodingMethod::Rfc2047 => "Rfc2047",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for ParamEncodingMethod {
    type GlibType = ffi::GMimeParamEncodingMethod;

    fn to_glib(&self) -> ffi::GMimeParamEncodingMethod {
        match *self {
            ParamEncodingMethod::Default => ffi::GMIME_PARAM_ENCODING_METHOD_DEFAULT,
            ParamEncodingMethod::Rfc2231 => ffi::GMIME_PARAM_ENCODING_METHOD_RFC2231,
            ParamEncodingMethod::Rfc2047 => ffi::GMIME_PARAM_ENCODING_METHOD_RFC2047,
            ParamEncodingMethod::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeParamEncodingMethod> for ParamEncodingMethod {
    fn from_glib(value: ffi::GMimeParamEncodingMethod) -> Self {
        match value {
            0 => ParamEncodingMethod::Default,
            1 => ParamEncodingMethod::Rfc2231,
            2 => ParamEncodingMethod::Rfc2047,
            value => ParamEncodingMethod::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum PubKeyAlgo {
    Default,
    Rsa,
    RsaE,
    RsaS,
    ElgE,
    Dsa,
    Ecc,
    Elg,
    Ecdsa,
    Ecdh,
    Eddsa,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for PubKeyAlgo {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "PubKeyAlgo::{}", match *self {
            PubKeyAlgo::Default => "Default",
            PubKeyAlgo::Rsa => "Rsa",
            PubKeyAlgo::RsaE => "RsaE",
            PubKeyAlgo::RsaS => "RsaS",
            PubKeyAlgo::ElgE => "ElgE",
            PubKeyAlgo::Dsa => "Dsa",
            PubKeyAlgo::Ecc => "Ecc",
            PubKeyAlgo::Elg => "Elg",
            PubKeyAlgo::Ecdsa => "Ecdsa",
            PubKeyAlgo::Ecdh => "Ecdh",
            PubKeyAlgo::Eddsa => "Eddsa",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for PubKeyAlgo {
    type GlibType = ffi::GMimePubKeyAlgo;

    fn to_glib(&self) -> ffi::GMimePubKeyAlgo {
        match *self {
            PubKeyAlgo::Default => ffi::GMIME_PUBKEY_ALGO_DEFAULT,
            PubKeyAlgo::Rsa => ffi::GMIME_PUBKEY_ALGO_RSA,
            PubKeyAlgo::RsaE => ffi::GMIME_PUBKEY_ALGO_RSA_E,
            PubKeyAlgo::RsaS => ffi::GMIME_PUBKEY_ALGO_RSA_S,
            PubKeyAlgo::ElgE => ffi::GMIME_PUBKEY_ALGO_ELG_E,
            PubKeyAlgo::Dsa => ffi::GMIME_PUBKEY_ALGO_DSA,
            PubKeyAlgo::Ecc => ffi::GMIME_PUBKEY_ALGO_ECC,
            PubKeyAlgo::Elg => ffi::GMIME_PUBKEY_ALGO_ELG,
            PubKeyAlgo::Ecdsa => ffi::GMIME_PUBKEY_ALGO_ECDSA,
            PubKeyAlgo::Ecdh => ffi::GMIME_PUBKEY_ALGO_ECDH,
            PubKeyAlgo::Eddsa => ffi::GMIME_PUBKEY_ALGO_EDDSA,
            PubKeyAlgo::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimePubKeyAlgo> for PubKeyAlgo {
    fn from_glib(value: ffi::GMimePubKeyAlgo) -> Self {
        match value {
            0 => PubKeyAlgo::Default,
            1 => PubKeyAlgo::Rsa,
            2 => PubKeyAlgo::RsaE,
            3 => PubKeyAlgo::RsaS,
            16 => PubKeyAlgo::ElgE,
            17 => PubKeyAlgo::Dsa,
            18 => PubKeyAlgo::Ecc,
            20 => PubKeyAlgo::Elg,
            301 => PubKeyAlgo::Ecdsa,
            302 => PubKeyAlgo::Ecdh,
            303 => PubKeyAlgo::Eddsa,
            value => PubKeyAlgo::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum RfcComplianceMode {
    Loose,
    Strict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for RfcComplianceMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "RfcComplianceMode::{}", match *self {
            RfcComplianceMode::Loose => "Loose",
            RfcComplianceMode::Strict => "Strict",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for RfcComplianceMode {
    type GlibType = ffi::GMimeRfcComplianceMode;

    fn to_glib(&self) -> ffi::GMimeRfcComplianceMode {
        match *self {
            RfcComplianceMode::Loose => ffi::GMIME_RFC_COMPLIANCE_LOOSE,
            RfcComplianceMode::Strict => ffi::GMIME_RFC_COMPLIANCE_STRICT,
            RfcComplianceMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeRfcComplianceMode> for RfcComplianceMode {
    fn from_glib(value: ffi::GMimeRfcComplianceMode) -> Self {
        match value {
            0 => RfcComplianceMode::Loose,
            1 => RfcComplianceMode::Strict,
            value => RfcComplianceMode::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum SecureMimeType {
    CompressedData,
    EnvelopedData,
    SignedData,
    CertsOnly,
    Unknown,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SecureMimeType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SecureMimeType::{}", match *self {
            SecureMimeType::CompressedData => "CompressedData",
            SecureMimeType::EnvelopedData => "EnvelopedData",
            SecureMimeType::SignedData => "SignedData",
            SecureMimeType::CertsOnly => "CertsOnly",
            SecureMimeType::Unknown => "Unknown",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SecureMimeType {
    type GlibType = ffi::GMimeSecureMimeType;

    fn to_glib(&self) -> ffi::GMimeSecureMimeType {
        match *self {
            SecureMimeType::CompressedData => ffi::GMIME_SECURE_MIME_TYPE_COMPRESSED_DATA,
            SecureMimeType::EnvelopedData => ffi::GMIME_SECURE_MIME_TYPE_ENVELOPED_DATA,
            SecureMimeType::SignedData => ffi::GMIME_SECURE_MIME_TYPE_SIGNED_DATA,
            SecureMimeType::CertsOnly => ffi::GMIME_SECURE_MIME_TYPE_CERTS_ONLY,
            SecureMimeType::Unknown => ffi::GMIME_SECURE_MIME_TYPE_UNKNOWN,
            SecureMimeType::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeSecureMimeType> for SecureMimeType {
    fn from_glib(value: ffi::GMimeSecureMimeType) -> Self {
        match value {
            0 => SecureMimeType::CompressedData,
            1 => SecureMimeType::EnvelopedData,
            2 => SecureMimeType::SignedData,
            3 => SecureMimeType::CertsOnly,
            4 => SecureMimeType::Unknown,
            value => SecureMimeType::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum SeekWhence {
    Set,
    Cur,
    End,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SeekWhence {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SeekWhence::{}", match *self {
            SeekWhence::Set => "Set",
            SeekWhence::Cur => "Cur",
            SeekWhence::End => "End",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SeekWhence {
    type GlibType = ffi::GMimeSeekWhence;

    fn to_glib(&self) -> ffi::GMimeSeekWhence {
        match *self {
            SeekWhence::Set => ffi::GMIME_STREAM_SEEK_SET,
            SeekWhence::Cur => ffi::GMIME_STREAM_SEEK_CUR,
            SeekWhence::End => ffi::GMIME_STREAM_SEEK_END,
            SeekWhence::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeSeekWhence> for SeekWhence {
    fn from_glib(value: ffi::GMimeSeekWhence) -> Self {
        match value {
            0 => SeekWhence::Set,
            1 => SeekWhence::Cur,
            2 => SeekWhence::End,
            value => SeekWhence::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum SignatureStatus {
    Valid,
    Green,
    Red,
    KeyRevoked,
    KeyExpired,
    SigExpired,
    KeyMissing,
    CrlMissing,
    CrlTooOld,
    BadPolicy,
    SysError,
    TofuConflict,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for SignatureStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "SignatureStatus::{}", match *self {
            SignatureStatus::Valid => "Valid",
            SignatureStatus::Green => "Green",
            SignatureStatus::Red => "Red",
            SignatureStatus::KeyRevoked => "KeyRevoked",
            SignatureStatus::KeyExpired => "KeyExpired",
            SignatureStatus::SigExpired => "SigExpired",
            SignatureStatus::KeyMissing => "KeyMissing",
            SignatureStatus::CrlMissing => "CrlMissing",
            SignatureStatus::CrlTooOld => "CrlTooOld",
            SignatureStatus::BadPolicy => "BadPolicy",
            SignatureStatus::SysError => "SysError",
            SignatureStatus::TofuConflict => "TofuConflict",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for SignatureStatus {
    type GlibType = ffi::GMimeSignatureStatus;

    fn to_glib(&self) -> ffi::GMimeSignatureStatus {
        match *self {
            SignatureStatus::Valid => ffi::GMIME_SIGNATURE_STATUS_VALID,
            SignatureStatus::Green => ffi::GMIME_SIGNATURE_STATUS_GREEN,
            SignatureStatus::Red => ffi::GMIME_SIGNATURE_STATUS_RED,
            SignatureStatus::KeyRevoked => ffi::GMIME_SIGNATURE_STATUS_KEY_REVOKED,
            SignatureStatus::KeyExpired => ffi::GMIME_SIGNATURE_STATUS_KEY_EXPIRED,
            SignatureStatus::SigExpired => ffi::GMIME_SIGNATURE_STATUS_SIG_EXPIRED,
            SignatureStatus::KeyMissing => ffi::GMIME_SIGNATURE_STATUS_KEY_MISSING,
            SignatureStatus::CrlMissing => ffi::GMIME_SIGNATURE_STATUS_CRL_MISSING,
            SignatureStatus::CrlTooOld => ffi::GMIME_SIGNATURE_STATUS_CRL_TOO_OLD,
            SignatureStatus::BadPolicy => ffi::GMIME_SIGNATURE_STATUS_BAD_POLICY,
            SignatureStatus::SysError => ffi::GMIME_SIGNATURE_STATUS_SYS_ERROR,
            SignatureStatus::TofuConflict => ffi::GMIME_SIGNATURE_STATUS_TOFU_CONFLICT,
            SignatureStatus::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeSignatureStatus> for SignatureStatus {
    fn from_glib(value: ffi::GMimeSignatureStatus) -> Self {
        match value {
            1 => SignatureStatus::Valid,
            2 => SignatureStatus::Green,
            4 => SignatureStatus::Red,
            16 => SignatureStatus::KeyRevoked,
            32 => SignatureStatus::KeyExpired,
            64 => SignatureStatus::SigExpired,
            128 => SignatureStatus::KeyMissing,
            256 => SignatureStatus::CrlMissing,
            512 => SignatureStatus::CrlTooOld,
            1024 => SignatureStatus::BadPolicy,
            2048 => SignatureStatus::SysError,
            4096 => SignatureStatus::TofuConflict,
            value => SignatureStatus::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum StreamBufferMode {
    Read,
    Write,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for StreamBufferMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "StreamBufferMode::{}", match *self {
            StreamBufferMode::Read => "Read",
            StreamBufferMode::Write => "Write",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for StreamBufferMode {
    type GlibType = ffi::GMimeStreamBufferMode;

    fn to_glib(&self) -> ffi::GMimeStreamBufferMode {
        match *self {
            StreamBufferMode::Read => ffi::GMIME_STREAM_BUFFER_BLOCK_READ,
            StreamBufferMode::Write => ffi::GMIME_STREAM_BUFFER_BLOCK_WRITE,
            StreamBufferMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeStreamBufferMode> for StreamBufferMode {
    fn from_glib(value: ffi::GMimeStreamBufferMode) -> Self {
        match value {
            0 => StreamBufferMode::Read,
            1 => StreamBufferMode::Write,
            value => StreamBufferMode::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Trust {
    Unknown,
    Undefined,
    Never,
    Marginal,
    Full,
    Ultimate,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Trust {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Trust::{}", match *self {
            Trust::Unknown => "Unknown",
            Trust::Undefined => "Undefined",
            Trust::Never => "Never",
            Trust::Marginal => "Marginal",
            Trust::Full => "Full",
            Trust::Ultimate => "Ultimate",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Trust {
    type GlibType = ffi::GMimeTrust;

    fn to_glib(&self) -> ffi::GMimeTrust {
        match *self {
            Trust::Unknown => ffi::GMIME_TRUST_UNKNOWN,
            Trust::Undefined => ffi::GMIME_TRUST_UNDEFINED,
            Trust::Never => ffi::GMIME_TRUST_NEVER,
            Trust::Marginal => ffi::GMIME_TRUST_MARGINAL,
            Trust::Full => ffi::GMIME_TRUST_FULL,
            Trust::Ultimate => ffi::GMIME_TRUST_ULTIMATE,
            Trust::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeTrust> for Trust {
    fn from_glib(value: ffi::GMimeTrust) -> Self {
        match value {
            0 => Trust::Unknown,
            1 => Trust::Undefined,
            2 => Trust::Never,
            3 => Trust::Marginal,
            4 => Trust::Full,
            5 => Trust::Ultimate,
            value => Trust::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum Validity {
    Unknown,
    Undefined,
    Never,
    Marginal,
    Full,
    Ultimate,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for Validity {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Validity::{}", match *self {
            Validity::Unknown => "Unknown",
            Validity::Undefined => "Undefined",
            Validity::Never => "Never",
            Validity::Marginal => "Marginal",
            Validity::Full => "Full",
            Validity::Ultimate => "Ultimate",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for Validity {
    type GlibType = ffi::GMimeValidity;

    fn to_glib(&self) -> ffi::GMimeValidity {
        match *self {
            Validity::Unknown => ffi::GMIME_VALIDITY_UNKNOWN,
            Validity::Undefined => ffi::GMIME_VALIDITY_UNDEFINED,
            Validity::Never => ffi::GMIME_VALIDITY_NEVER,
            Validity::Marginal => ffi::GMIME_VALIDITY_MARGINAL,
            Validity::Full => ffi::GMIME_VALIDITY_FULL,
            Validity::Ultimate => ffi::GMIME_VALIDITY_ULTIMATE,
            Validity::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeValidity> for Validity {
    fn from_glib(value: ffi::GMimeValidity) -> Self {
        match value {
            0 => Validity::Unknown,
            1 => Validity::Undefined,
            2 => Validity::Never,
            3 => Validity::Marginal,
            4 => Validity::Full,
            5 => Validity::Ultimate,
            value => Validity::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum VerifyFlags {
    VerifyNone,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for VerifyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "VerifyFlags::{}", match *self {
            VerifyFlags::VerifyNone => "VerifyNone",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for VerifyFlags {
    type GlibType = ffi::GMimeVerifyFlags;

    fn to_glib(&self) -> ffi::GMimeVerifyFlags {
        match *self {
            VerifyFlags::VerifyNone => ffi::GMIME_VERIFY_NONE,
            VerifyFlags::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeVerifyFlags> for VerifyFlags {
    fn from_glib(value: ffi::GMimeVerifyFlags) -> Self {
        match value {
            0 => VerifyFlags::VerifyNone,
            value => VerifyFlags::__Unknown(value),
        }
    }
}

