// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/vhdirk/gir-files.git)
// DO NOT EDIT

use bitflags::{bitflags};
use glib::{translate::*};
use std::{fmt};

bitflags! {
    #[doc(alias = "GMimeDecryptFlags")]
    pub struct DecryptFlags: u32 {
        #[doc(alias = "GMIME_DECRYPT_NONE")]
        const NONE = ffi::GMIME_DECRYPT_NONE as _;
        #[doc(alias = "GMIME_DECRYPT_EXPORT_SESSION_KEY")]
        const EXPORT_SESSION_KEY = ffi::GMIME_DECRYPT_EXPORT_SESSION_KEY as _;
        #[doc(alias = "GMIME_DECRYPT_NO_VERIFY")]
        const NO_VERIFY = ffi::GMIME_DECRYPT_NO_VERIFY as _;
        #[doc(alias = "GMIME_DECRYPT_ENABLE_KEYSERVER_LOOKUPS")]
        const ENABLE_KEYSERVER_LOOKUPS = ffi::GMIME_DECRYPT_ENABLE_KEYSERVER_LOOKUPS as _;
        #[doc(alias = "GMIME_DECRYPT_ENABLE_ONLINE_CERTIFICATE_CHECKS")]
        const ENABLE_ONLINE_CERTIFICATE_CHECKS = ffi::GMIME_DECRYPT_ENABLE_ONLINE_CERTIFICATE_CHECKS as _;
    }
}

impl fmt::Display for DecryptFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for DecryptFlags {
    type GlibType = ffi::GMimeDecryptFlags;

    #[inline]
    fn into_glib(self) -> ffi::GMimeDecryptFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeDecryptFlags> for DecryptFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GMimeDecryptFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

bitflags! {
    #[doc(alias = "GMimeEncryptFlags")]
    pub struct EncryptFlags: u32 {
        #[doc(alias = "GMIME_ENCRYPT_NONE")]
        const NONE = ffi::GMIME_ENCRYPT_NONE as _;
        #[doc(alias = "GMIME_ENCRYPT_ALWAYS_TRUST")]
        const ALWAYS_TRUST = ffi::GMIME_ENCRYPT_ALWAYS_TRUST as _;
        #[doc(alias = "GMIME_ENCRYPT_NO_COMPRESS")]
        const NO_COMPRESS = ffi::GMIME_ENCRYPT_NO_COMPRESS as _;
        #[doc(alias = "GMIME_ENCRYPT_SYMMETRIC")]
        const SYMMETRIC = ffi::GMIME_ENCRYPT_SYMMETRIC as _;
        #[doc(alias = "GMIME_ENCRYPT_THROW_KEYIDS")]
        const THROW_KEYIDS = ffi::GMIME_ENCRYPT_THROW_KEYIDS as _;
    }
}

impl fmt::Display for EncryptFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for EncryptFlags {
    type GlibType = ffi::GMimeEncryptFlags;

    #[inline]
    fn into_glib(self) -> ffi::GMimeEncryptFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeEncryptFlags> for EncryptFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GMimeEncryptFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

bitflags! {
    #[doc(alias = "GMimeFilterBestFlags")]
    pub struct FilterBestFlags: u32 {
        #[doc(alias = "GMIME_FILTER_BEST_CHARSET")]
        const CHARSET = ffi::GMIME_FILTER_BEST_CHARSET as _;
        #[doc(alias = "GMIME_FILTER_BEST_ENCODING")]
        const ENCODING = ffi::GMIME_FILTER_BEST_ENCODING as _;
    }
}

impl fmt::Display for FilterBestFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for FilterBestFlags {
    type GlibType = ffi::GMimeFilterBestFlags;

    #[inline]
    fn into_glib(self) -> ffi::GMimeFilterBestFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeFilterBestFlags> for FilterBestFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GMimeFilterBestFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
bitflags! {
    #[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
    #[doc(alias = "GMimeOpenPGPState")]
    pub struct OpenPGPState: u32 {
        #[doc(alias = "GMIME_OPENPGP_NONE")]
        const NONE = ffi::GMIME_OPENPGP_NONE as _;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_MESSAGE")]
        const BEGIN_PGP_MESSAGE = ffi::GMIME_OPENPGP_BEGIN_PGP_MESSAGE as _;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_MESSAGE")]
        const END_PGP_MESSAGE = ffi::GMIME_OPENPGP_END_PGP_MESSAGE as _;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_SIGNED_MESSAGE")]
        const BEGIN_PGP_SIGNED_MESSAGE = ffi::GMIME_OPENPGP_BEGIN_PGP_SIGNED_MESSAGE as _;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_SIGNATURE")]
        const BEGIN_PGP_SIGNATURE = ffi::GMIME_OPENPGP_BEGIN_PGP_SIGNATURE as _;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_SIGNATURE")]
        const END_PGP_SIGNATURE = ffi::GMIME_OPENPGP_END_PGP_SIGNATURE as _;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_PUBLIC_KEY_BLOCK")]
        const BEGIN_PGP_PUBLIC_KEY_BLOCK = ffi::GMIME_OPENPGP_BEGIN_PGP_PUBLIC_KEY_BLOCK as _;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_PUBLIC_KEY_BLOCK")]
        const END_PGP_PUBLIC_KEY_BLOCK = ffi::GMIME_OPENPGP_END_PGP_PUBLIC_KEY_BLOCK as _;
        #[doc(alias = "GMIME_OPENPGP_BEGIN_PGP_PRIVATE_KEY_BLOCK")]
        const BEGIN_PGP_PRIVATE_KEY_BLOCK = ffi::GMIME_OPENPGP_BEGIN_PGP_PRIVATE_KEY_BLOCK as _;
        #[doc(alias = "GMIME_OPENPGP_END_PGP_PRIVATE_KEY_BLOCK")]
        const END_PGP_PRIVATE_KEY_BLOCK = ffi::GMIME_OPENPGP_END_PGP_PRIVATE_KEY_BLOCK as _;
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
impl fmt::Display for OpenPGPState {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
#[doc(hidden)]
impl IntoGlib for OpenPGPState {
    type GlibType = ffi::GMimeOpenPGPState;

    #[inline]
    fn into_glib(self) -> ffi::GMimeOpenPGPState {
        self.bits()
    }
}

#[cfg(any(feature = "v3_2", feature = "dox"))]
#[cfg_attr(feature = "dox", doc(cfg(feature = "v3_2")))]
#[doc(hidden)]
impl FromGlib<ffi::GMimeOpenPGPState> for OpenPGPState {
    #[inline]
    unsafe fn from_glib(value: ffi::GMimeOpenPGPState) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

bitflags! {
    #[doc(alias = "GMimeVerifyFlags")]
    pub struct VerifyFlags: u32 {
        #[doc(alias = "GMIME_VERIFY_NONE")]
        const NONE = ffi::GMIME_VERIFY_NONE as _;
        #[doc(alias = "GMIME_VERIFY_ENABLE_KEYSERVER_LOOKUPS")]
        const ENABLE_KEYSERVER_LOOKUPS = ffi::GMIME_VERIFY_ENABLE_KEYSERVER_LOOKUPS as _;
        #[doc(alias = "GMIME_VERIFY_ENABLE_ONLINE_CERTIFICATE_CHECKS")]
        const ENABLE_ONLINE_CERTIFICATE_CHECKS = ffi::GMIME_VERIFY_ENABLE_ONLINE_CERTIFICATE_CHECKS as _;
    }
}

impl fmt::Display for VerifyFlags {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        <Self as fmt::Debug>::fmt(self, f)
    }
}

#[doc(hidden)]
impl IntoGlib for VerifyFlags {
    type GlibType = ffi::GMimeVerifyFlags;

    #[inline]
    fn into_glib(self) -> ffi::GMimeVerifyFlags {
        self.bits()
    }
}

#[doc(hidden)]
impl FromGlib<ffi::GMimeVerifyFlags> for VerifyFlags {
    #[inline]
    unsafe fn from_glib(value: ffi::GMimeVerifyFlags) -> Self {
        skip_assert_initialized!();
        Self::from_bits_truncate(value)
    }
}

