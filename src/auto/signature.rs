// This file was generated by gir (https://github.com/gtk-rs/gir @ 2f0a317)
// from gir-files (https://github.com/gtk-rs/gir-files @ b215ee8)
// DO NOT EDIT

use Certificate;
use SignatureStatus;
use ffi;
use glib::object::IsA;
use glib::translate::*;
use libc;
use std::fmt;

glib_wrapper! {
    pub struct Signature(Object<ffi::GMimeSignature, ffi::GMimeSignatureClass, SignatureClass>);

    match fn {
        get_type => || ffi::g_mime_signature_get_type(),
    }
}

impl Signature {
    pub fn new() -> Signature {
        unsafe {
            from_glib_full(ffi::g_mime_signature_new())
        }
    }
}

impl Default for Signature {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SIGNATURE: Option<&Signature> = None;

pub trait SignatureExt: 'static {
    fn get_certificate(&self) -> Option<Certificate>;

    fn get_created(&self) -> libc::c_long;

    fn get_expires(&self) -> libc::c_long;

    fn get_status(&self) -> SignatureStatus;

    fn set_certificate<P: IsA<Certificate>>(&self, cert: &P);

    fn set_created(&self, created: libc::c_long);

    fn set_expires(&self, expires: libc::c_long);

    fn set_status(&self, status: SignatureStatus);
}

impl<O: IsA<Signature>> SignatureExt for O {
    fn get_certificate(&self) -> Option<Certificate> {
        unsafe {
            from_glib_none(ffi::g_mime_signature_get_certificate(self.as_ref().to_glib_none().0))
        }
    }

    fn get_created(&self) -> libc::c_long {
        unsafe {
            ffi::g_mime_signature_get_created(self.as_ref().to_glib_none().0)
        }
    }

    fn get_expires(&self) -> libc::c_long {
        unsafe {
            ffi::g_mime_signature_get_expires(self.as_ref().to_glib_none().0)
        }
    }

    fn get_status(&self) -> SignatureStatus {
        unsafe {
            from_glib(ffi::g_mime_signature_get_status(self.as_ref().to_glib_none().0))
        }
    }

    fn set_certificate<P: IsA<Certificate>>(&self, cert: &P) {
        unsafe {
            ffi::g_mime_signature_set_certificate(self.as_ref().to_glib_none().0, cert.as_ref().to_glib_none().0);
        }
    }

    fn set_created(&self, created: libc::c_long) {
        unsafe {
            ffi::g_mime_signature_set_created(self.as_ref().to_glib_none().0, created);
        }
    }

    fn set_expires(&self, expires: libc::c_long) {
        unsafe {
            ffi::g_mime_signature_set_expires(self.as_ref().to_glib_none().0, expires);
        }
    }

    fn set_status(&self, status: SignatureStatus) {
        unsafe {
            ffi::g_mime_signature_set_status(self.as_ref().to_glib_none().0, status.to_glib());
        }
    }
}

impl fmt::Display for Signature {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Signature")
    }
}
