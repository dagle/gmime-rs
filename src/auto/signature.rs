// This file was generated by gir (https://github.com/gtk-rs/gir @ ad40c01)
// from gir-files (https://github.com/gtk-rs/gir-files @ 5b96546)
// DO NOT EDIT

use glib::object::IsA;
use glib::translate::*;
use gmime_sys;
use libc;
use std::fmt;
use Certificate;
use SignatureStatus;

glib_wrapper! {
    pub struct Signature(Object<gmime_sys::GMimeSignature, gmime_sys::GMimeSignatureClass, SignatureClass>);

    match fn {
        get_type => || gmime_sys::g_mime_signature_get_type(),
    }
}

impl Signature {
    pub fn new() -> Signature {
        unsafe {
            from_glib_full(gmime_sys::g_mime_signature_new())
        }
    }
}

impl Default for Signature {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_SIGNATURE: Option<&Signature> = None;

pub trait SignatureExt: 'static {
    fn get_certificate(&self) -> Option<Certificate>;

    fn get_created(&self) -> libc::c_long;

    fn get_created64(&self) -> i64;

    fn get_expires(&self) -> libc::c_long;

    fn get_expires64(&self) -> i64;

    fn get_status(&self) -> SignatureStatus;

    fn set_certificate<P: IsA<Certificate>>(&self, cert: &P);

    fn set_created(&self, created: libc::c_long);

    fn set_expires(&self, expires: libc::c_long);

    fn set_status(&self, status: SignatureStatus);
}

impl<O: IsA<Signature>> SignatureExt for O {
    fn get_certificate(&self) -> Option<Certificate> {
        unsafe {
            from_glib_none(gmime_sys::g_mime_signature_get_certificate(self.as_ref().to_glib_none().0))
        }
    }

    fn get_created(&self) -> libc::c_long {
        unsafe {
            gmime_sys::g_mime_signature_get_created(self.as_ref().to_glib_none().0)
        }
    }

    fn get_created64(&self) -> i64 {
        unsafe {
            gmime_sys::g_mime_signature_get_created64(self.as_ref().to_glib_none().0)
        }
    }

    fn get_expires(&self) -> libc::c_long {
        unsafe {
            gmime_sys::g_mime_signature_get_expires(self.as_ref().to_glib_none().0)
        }
    }

    fn get_expires64(&self) -> i64 {
        unsafe {
            gmime_sys::g_mime_signature_get_expires64(self.as_ref().to_glib_none().0)
        }
    }

    fn get_status(&self) -> SignatureStatus {
        unsafe {
            from_glib(gmime_sys::g_mime_signature_get_status(self.as_ref().to_glib_none().0))
        }
    }

    fn set_certificate<P: IsA<Certificate>>(&self, cert: &P) {
        unsafe {
            gmime_sys::g_mime_signature_set_certificate(self.as_ref().to_glib_none().0, cert.as_ref().to_glib_none().0);
        }
    }

    fn set_created(&self, created: libc::c_long) {
        unsafe {
            gmime_sys::g_mime_signature_set_created(self.as_ref().to_glib_none().0, created);
        }
    }

    fn set_expires(&self, expires: libc::c_long) {
        unsafe {
            gmime_sys::g_mime_signature_set_expires(self.as_ref().to_glib_none().0, expires);
        }
    }

    fn set_status(&self, status: SignatureStatus) {
        unsafe {
            gmime_sys::g_mime_signature_set_status(self.as_ref().to_glib_none().0, status.to_glib());
        }
    }
}

impl fmt::Display for Signature {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Signature")
    }
}
